Folder: hosting/src\api
Filename: firebaseApi.jsx
Contents:
import { db } from '../firebase/firebaseConfig';
import { collection, doc, setDoc, getDoc, updateDoc, query, where, onSnapshot, GeoPoint, serverTimestamp } from 'firebase/firestore';

// Function to create a new ride request
export async function createRideRequest(paymentIntent, rideDetails) {
  console.log('firebaseAPI: Creating a new ride request with details:', rideDetails);

  const rideRequestRef = doc(collection(db, 'rideRequests'));
  try {
    await setDoc(rideRequestRef, {
      id: rideRequestRef.id,
      paymentIntentId: paymentIntent.id,
      hostId: rideDetails.hostId,
      rideFee: rideDetails.amount,
      user_uid: rideDetails.userId,
      user_name: rideDetails.userName,
      user_location: new GeoPoint(rideDetails.userLocation.latitude, rideDetails.userLocation.longitude),
      destination_location: new GeoPoint(rideDetails.destinationLocation.latitude, rideDetails.destinationLocation.longitude),
      status: 'pending',
      is_driver_assigned: false,
      createdAt: serverTimestamp(),
    });
    console.log('firebaseAPI: Ride request created successfully with ID:', rideRequestRef.id);
  } catch (error) {
    console.error('firebaseAPI: Error creating ride request', error);
    throw error;
  }
}

// Function to update a booking
export async function updateBooking(rideRequestId, bookingData) {
  console.log('firebaseAPI: Updating booking with ID:', rideRequestId, 'and data:', bookingData);

  const bookingRef = doc(db, 'bookings', rideRequestId);
  try {
    await updateDoc(bookingRef, {
      ...bookingData,
      updated_at: serverTimestamp(),
    });
    console.log('firebaseAPI: Booking updated successfully');
  } catch (error) {
    console.error('firebaseAPI: Error updating booking', error);
    throw error;
  }
}

// Function to fetch user profile data
export async function getProfileData(userId) {
  console.log('firebaseAPI: Fetching profile data for user ID:', userId);

  const userDocRef = doc(db, 'users', userId);
  try {
    const userDoc = await getDoc(userDocRef);
    if (userDoc.exists()) {
      console.log('firebaseAPI: Profile data fetched successfully:', userDoc.data());
      return userDoc.data();
    } else {
      console.warn('firebaseAPI: No profile data found for user ID:', userId);
      return null;
    }
  } catch (error) {
    console.error('firebaseAPI: Error fetching profile data', error);
    throw error;
  }
}

// Function to save user profile data
export async function saveProfileData(userId, profileData) {
  console.log('firebaseAPI: Saving profile data for user ID:', userId, 'with data:', profileData);

  const userDocRef = doc(db, 'users', userId);
  try {
    await setDoc(userDocRef, profileData, { merge: true });
    console.log('firebaseAPI: Profile data saved successfully');
  } catch (error) {
    console.error('firebaseAPI: Error saving profile data', error);
    throw error;
  }
}

// Function to listen for ride requests
export function listenToRideRequests(callback) {
  console.log('firebaseAPI: Setting up listener for ride requests');

  const q = query(collection(db, 'rideRequests'), where('is_driver_assigned', '==', false));
  const unsubscribe = onSnapshot(q, (snapshot) => {
    const rideRequests = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    console.log('firebaseAPI: Ride requests snapshot updated:', rideRequests);
    callback(rideRequests);
  }, (error) => {
    console.error('firebaseAPI: Error listening to ride requests', error);
  });

  return unsubscribe;
}



================================================================================

Folder: hosting/src\context
Filename: FirebaseContext.jsx
Contents:
import { createContext, useContext, useEffect, useState, useMemo } from 'react';
import PropTypes from 'prop-types';
import { auth, db } from '../firebase/firebaseConfig'; 

// Create a Firebase Context
const FirebaseContext = createContext(null);

// Firebase Provider Component
export const FirebaseProvider = ({ children }) => {
  console.log('FirebaseContext: Initializing Firebase Provider');
  
  const [user, setUser] = useState(null);

  useEffect(() => {
    console.log('FirebaseContext: Setting up Firebase Auth listener');
    
    // Listen for auth state changes
    const unsubscribe = auth.onAuthStateChanged((currentUser) => {
      if (currentUser) {
        console.log('FirebaseContext: User logged in', currentUser);
        setUser(currentUser);
      } else {
        console.log('FirebaseContext: No user logged in');
        setUser(null);
      }
    });

    // Cleanup subscription on unmount
    return () => unsubscribe();
  }, []);

  // Use useMemo to memoize the context value
  const firebaseContextValue = useMemo(() => ({ user, db }), [user, db]);

  return (
    <FirebaseContext.Provider value={firebaseContextValue}>
      {children}
    </FirebaseContext.Provider>
  );
};

// Define PropTypes for FirebaseProvider
FirebaseProvider.propTypes = {
  children: PropTypes.node.isRequired,
};

// Custom hook to use Firebase Context
const useFirebase = () => {
  const context = useContext(FirebaseContext);
  
  if (!context) {
    throw new Error('useFirebase must be used within a FirebaseProvider');
  }
  
  return context;
};

export {useFirebase} ;


================================================================================

Folder: hosting/src\context
Filename: useFirebaseContext.jsx
Contents:
import { useContext } from 'react';
import { FirebaseContext } from './FirebaseContext';

const useFirebaseContext = () => {
  console.log('useFirebaseContext: Accessing Firebase context');
  const context = useContext(FirebaseContext);

  if (!context) {
    console.error('useFirebaseContext must be used within a FirebaseProvider');
    throw new Error('useFirebaseContext must be used within a FirebaseProvider');
  }

  return context;
};

export default useFirebaseContext;




================================================================================

Folder: hosting/src\firebase
Filename: firebaseConfig.jsx
Contents:
import { initializeApp } from 'firebase/app';
import { getAuth } from 'firebase/auth';
import { getFirestore } from 'firebase/firestore';
import { getStorage } from 'firebase/storage';

// Firebase configuration object containing keys and identifiers for your app
const firebaseConfig = {
  apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
  authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
  projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
  storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
  appId: import.meta.env.VITE_FIREBASE_APP_ID,
  measurementId: import.meta.env.VITE_FIREBASE_MEASUREMENT_ID,
};
console.log(firebaseConfig);

// Initialize Firebase app
const app = initializeApp(firebaseConfig);

// Export Firebase services for use in the app
export const auth = getAuth(app);
export const db = getFirestore(app);
export const storage = getStorage(app);


================================================================================

Folder: hosting/src\utils
Filename: firebaseUtils.jsx
Contents:
// convertTimestamp(timestamp): Convert Firestore timestamp to JavaScript Date object.
//Other reusable functions like data manipulation or utility helpers.

// Convert Firestore timestamp to JavaScript Date object
export const convertTimestamp = (timestamp) => {
    if (!timestamp) return null;
    return timestamp.toDate();
  };
  

================================================================================

Contents of app.jsx:
// src/App.js
import React, { useState, useEffect } from 'react';
import { collection, getDocs } from 'firebase/firestore';
import { ChakraProvider } from '@chakra-ui/react';
import { Elements } from '@stripe/react-stripe-js';
import { loadStripe } from '@stripe/stripe-js';

// Context Providers
import { FirebaseProvider } from './context/FirebaseContext.jsx';
import { ErrorBoundary } from './context/ErrorBoundary.jsx';
import { MapsProvider } from './context/MapsContext.jsx';
import { StripeProvider } from './context/StripeContext.jsx';
import { AuthProvider } from './context/AuthContext.jsx';

// Components
import Header from './components/Header.jsx';
import LeftPanel from './components/LeftPanel.jsx';
import RightPanel from './components/RightPanel.jsx';
import Footer from './components/Footer.jsx';
import SearchBar from './components/SearchBar.jsx';
import Dashboard from './components/Dashboard.jsx';
import ActiveContainer from './components/ActiveContainer.jsx';
import MapComponent from './components/MapComponent.jsx';

// Stripe API functions
import { 
  handleCreateStripeOnboarding, 
  handleCreateCheckoutSession, 
  handleCapturePaymentIntent, 
  handleCancelPaymentIntent 
} from './api/stripeApi'; // Importing Stripe API functions

// Styles
import './App.css';

// Firebase Config
import { db } from './firebase/firebaseConfig';

// Stripe Configuration
const stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY);

const App = () => {
  const [darkMode, setDarkMode] = useState(false);
  const [appMode, setAppMode] = useState('rabbit'); // 'rabbit' or 'host'
  const [isRightPanelOpen, setIsRightPanelOpen] = useState(false);
  const [selectedItem, setSelectedItem] = useState(null);
  const [rideInProgress, setRideInProgress] = useState(false);
  const [activeCategory, setActiveCategory] = useState('all');
  const [viewType, setViewType] = useState('list');
  const [businesses, setBusinesses] = useState([]);
  const [filteredBusinesses, setFilteredBusinesses] = useState([]);
  const [chatMessages, setChatMessages] = useState([]);
  const [chatInput, setChatInput] = useState('');
  const [userEmail, setUserEmail] = useState('test@example.com');
  const [paymentIntentId, setPaymentIntentId] = useState(null);
  const [paymentIntentStatus, setPaymentIntentStatus] = useState('');
  const [message, setMessage] = useState(''); // State for displaying messages

  // Fetch businesses data from Firebase
  useEffect(() => {
    const fetchBusinesses = async () => {
      try {
        const querySnapshot = await getDocs(collection(db, 'places'));
        const businessesData = querySnapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));
        setBusinesses(businessesData);
        setFilteredBusinesses(businessesData);
      } catch (error) {
        console.error('Error fetching businesses from Firebase:', error);
      }
    };

    fetchBusinesses();
  }, []);

  // Update filtered businesses based on the active category
  useEffect(() => {
    if (activeCategory === 'all') {
      setFilteredBusinesses(businesses);
    } else {
      setFilteredBusinesses(businesses.filter((business) => business.category === activeCategory));
    }
  }, [activeCategory, businesses]);

  // Handle accepting a ride
  const handleAccept = (ride) => {
    setSelectedItem(ride);
    setIsRightPanelOpen(true); // Show right panel for details
    setRideInProgress(true);
    setChatMessages([
      { sender: 'guest', text: 'Hello! Looking forward to the ride.' },
      { sender: 'host', text: 'Hi! I will be there in 5 minutes.' },
    ]);
  };

  // Handle selecting an item
  const handleSelectItem = (item) => {
    setSelectedItem(item);
    setIsRightPanelOpen(true); // Show right panel for details
  };

  // Handle toggling the right panel
  const handleToggleRightPanel = () => {
    setIsRightPanelOpen(!isRightPanelOpen);
  };

  // Handle sending a message in the chat
  const sendMessage = () => {
    if (chatInput.trim()) {
      const newMessage = { sender: 'host', text: chatInput };
      setChatMessages((prevMessages) => [...prevMessages, newMessage]);
      setChatInput('');
    }
  };

  // Cancel an active ride
  const cancelRide = () => {
    setRideInProgress(false);
    setSelectedItem(null);
  };

  // Handle booking a ride
  const handleBookRide = () => {
    console.log('Booking a ride');
  };

  // Update payment intent
  const handlePaymentIntentUpdate = (id, status) => {
    setPaymentIntentId(id);
    setPaymentIntentStatus(status);
  };

  // Stripe functions for handling payments and onboarding
  const startStripeOnboarding = async () => {
    try {
      await handleCreateStripeOnboarding(userEmail);
    } catch (error) {
      console.error('Error starting Stripe onboarding:', error);
      setMessage(error.message);
    }
  };

  const createStripeCheckoutSession = async () => {
    try {
      const response = await handleCreateCheckoutSession(1000, userEmail); // Example amount in cents
      setMessage(`Redirecting to Stripe Checkout...`);
      window.location.href = response.url; // Redirect to Stripe Checkout
    } catch (error) {
      console.error('Error creating Stripe checkout session:', error);
      setMessage(error.message);
    }
  };

  const captureStripePaymentIntent = async () => {
    try {
      const response = await handleCapturePaymentIntent(paymentIntentId, userEmail);
      setMessage(`Payment Intent captured: ${response.id}`);
    } catch (error) {
      console.error('Error capturing payment intent:', error);
      setMessage(error.message);
    }
  };

  const cancelStripePaymentIntent = async () => {
    try {
      const response = await handleCancelPaymentIntent(paymentIntentId);
      setMessage(`Payment Intent canceled: ${response.id}`);
    } catch (error) {
      console.error('Error canceling payment intent:', error);
      setMessage(error.message);
    }
  };

  return (
    <div className={`flex flex-col h-screen ${darkMode ? 'dark' : ''}`}>
      <ErrorBoundary>
        <FirebaseProvider>
          <AuthProvider>
            <ChakraProvider>
              <MapsProvider apiKey={import.meta.env.VITE_GOOGLE_MAPS_API_KEY}>
                <Elements stripe={stripePromise}>
                  <StripeProvider>
                    <SearchBar
                      userEmail={userEmail}
                      paymentIntentId={paymentIntentId}
                      paymentIntentStatus={paymentIntentStatus}
                      onPaymentIntentUpdate={handlePaymentIntentUpdate}
                      onBookRide={handleBookRide}
                    />
                    <Header
                      darkMode={darkMode}
                      setDarkMode={setDarkMode}
                      appMode={appMode}
                      setAppMode={setAppMode}
                      setIsLeftPanelOpen={() => {}} // Not needed anymore since left panel is always open
                      setIsRightPanelOpen={setIsRightPanelOpen}
                    />
                    <div className="flex flex-1 overflow-hidden">
                      {/* Left Panel - Always Visible */}
                      <LeftPanel
                        isOpen={true}
                        setIsOpen={() => {}}
                        appMode={appMode}
                        handleAccept={handleAccept}
                        handleSelectItem={handleSelectItem}
                        activeCategory={activeCategory}
                        setActiveCategory={setActiveCategory}
                        viewType={viewType}
                        setViewType={setViewType}
                        rideInProgress={rideInProgress}
                        handleSettingsClick={handleToggleRightPanel} // Toggle the right panel
                        businesses={filteredBusinesses}
                      />

                      {/* Main Content - Visible under the Right Panel */}
                      <main className={`flex-1 flex flex-col relative transition-all duration-300 ${isRightPanelOpen ? 'mr-64' : ''}`}>
                        {appMode === 'rabbit' && !rideInProgress && (
                          <>
                            <Dashboard />
                            <MapComponent businesses={filteredBusinesses} />
                          </>
                        )}
                        {appMode === 'rabbit' && rideInProgress && (
                          <ActiveContainer
                            chatMessages={chatMessages}
                            chatInput={chatInput}
                            setChatInput={setChatInput}
                            sendMessage={sendMessage}
                            cancelAction={cancelRide}
                          />
                        )}
                        {appMode === 'host' && (
                          <Dashboard />
                        )}
                      </main>

                      {/* Right Panel - Toggles visibility */}
                      <RightPanel
                        isOpen={isRightPanelOpen}
                        setIsOpen={setIsRightPanelOpen}
                        selectedItem={selectedItem}
                        appMode={appMode}
                        startStripeOnboarding={startStripeOnboarding}
                        createStripeCheckoutSession={createStripeCheckoutSession}
                        captureStripePaymentIntent={captureStripePaymentIntent}
                        cancelStripePaymentIntent={cancelStripePaymentIntent}
                        message={message}
                      />
                    </div>
                    <Footer />
                  </StripeProvider>
                </Elements>
              </MapsProvider>
            </ChakraProvider>
          </AuthProvider>
        </FirebaseProvider>
      </ErrorBoundary>
    </div>
  );
};

export default App;

